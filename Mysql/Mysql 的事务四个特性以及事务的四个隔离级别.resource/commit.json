{"compress":true,"commitItems":[["568f5528-98e5-4999-8dd6-8f9f2298adea",1630380565704,"---\ntitle: Mysql 的事务四个特性以及事务的四个隔离级别\ntags: \n\t  - Mysql\ncategories: \"Mysql\"\nabbrlink: 011a\ndate: 2019-07-23 14:37:57\n---\n\n\n<img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1563878149907&di=d54d657f25322e307ee5dadeb164a1c9&imgtype=0&src=http%3A%2F%2Fimg.draveness.me%2Fmysql.png\" style=\"width:900px;height:400px\" />\n\n## 前言\n\n事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据应用该组查询的全部语句，那么久执行该组查询。如果其中任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。\n\n<!--less-->\n\n# mysql的事务四个特性以及事务的四个隔离级别\n=======================\n\n事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据应用该组查询的全部语句，那么久执行该组查询。如果其中任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。\n\n事务的四大特性（ACID）\n-------------\n\n- 原子性（atomicity）：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。\n- 一致性（consistency）：数据库总数从一个一致性的状态转换到另一个一致性的状态。\n- 隔离性（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。\n- 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。\n\n数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。\n\n事务的四种隔离级别\n---------\n\n### Read uncommitted\n\n读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。\n\n事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。\n\n分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。\n\n`那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。`\n\n### Read committed\n\n读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。\n\n事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…\n\n分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。\n\n`那怎么解决可能的不可重复读问题？Repeatable read ！`\n\n### Repeatable read\n\n重复读，就是在开始读取数据（事务开启）时，不再允许修改操作\n\n事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。\n\n分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。\n\n什么时候会出现幻读？\n\n事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。\n\n`那怎么解决幻读问题？Serializable！`\n\n### Serializable 序列化\n\nSerializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。\n\n`值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。MySQL的默认隔离级别是Repeatable read`\n\n- - - - - -\n\n作者：csdnxingyuntian 来源：CSDN 原文：<https://blog.csdn.net/csdnxingyuntian/article/details/57081233>版权声明：本文为博主原创文章，转载请附上博文链接！\na",[[1630380564146,["Administrator@YMS-20200313EGD",[[-1,85,"11a"]],[84,88],[85,85]]],[1630380564833,["Administrator@YMS-20200313EGD",[[1,85,"01a"]],[85,85],[88,88]]],[1630380567158,["Administrator@YMS-20200313EGD",[[-1,85,"01a"]],[88,88],[85,85]]],[1630380567556,["Administrator@YMS-20200313EGD",[[1,85,"11a"]],[85,85],[84,88]]],[1630380569216,["Administrator@YMS-20200313EGD",[[-1,84,"011a"]],[84,88],[84,84]]],[1630380575058,["Administrator@YMS-20200313EGD",[[1,84,"001a"]],[84,84],[88,88]]]],null,"Administrator@YMS-20200313EGD"]]}