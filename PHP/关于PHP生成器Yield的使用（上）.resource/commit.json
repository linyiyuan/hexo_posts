{"compress":true,"commitItems":[["7a17f14e-f9be-492e-aef4-d432407f4931",1630380691695,"---\nlayout: 关于PHP生成器Yield的使用（上）\ntitle: 关于PHP生成器Yield的使用（上）\ndate: 2019-09-07 15:42:45\ncategories: \"PHP\"\nabbrlink: 006a\ntags: \n- PHP\n---\n\n<img src=\"http://images.linyiyuan.top/af02a20aff73011ad4cbaedb76724c38.jpg\" style=\"width:900px;height:400px\" />\n\nPHP的`Yield` 关键字是php5.5版本推出的一个特性，算是比较古老的了，其他很多语言中也有类似的特性存在。但是在实际的项目中，目前用到还比较少。网上相关的文章最出名的就是鸟哥的那篇了，下面为大家介绍这一强大的神器\n\n<!--less-->\n## 前言\n在认识这个强大的神器之前我们先了解几个常见PHP内置函数内存相关常见常数，\n1. memory_get_usage(): 返回当前分配给PHP脚本的内存量，单位是字节（byte）\n2. memory_get_peak_usage(): 返回内存使用峰值\n3. getrusage():返回CUP使用情况\n\n我们在日常开发中可以使用这些内置函数来调试PHP代码性能。但需要注意的是这几个函数只能在linux系统中使用\n\n在认识以上三个函数之后我们来做一个简单的小测, 我们迭代数组一个1-1000的数组\n```php\n$start_memory = memory_get_usage();\n\n$numberArr = range(1, 1000);\nforeach($numberArr as $key) {\n  //echo $key;\n}\n$end_memory = memory_get_usage();\n\necho '运行该迭代数组所耗内存：'  . ($end_memory - $start_memory) . 'bytes';\n```\n\n运行结果：\n\n    运行该迭代数组所耗内存：528440 bytes\n\n折算成kb单位就是大概是528kb, 这样一看并没觉得什么，这时候我们继续增大数组范围，我们将范围扩大成1-1000000\n\n运行结果：\n\n    运行该迭代数组所耗内存：4198480 bytes\n\n大概是4m左右，这时候还是可以遍历得出来，我们继续增大1-10000000\n\n运行结果：\n\n**Fatal error**: Allowed memory size of 134217728 bytes exhausted (tried to allocate 536870920 bytes) in **/data/default/index.php** on line **11**\n\n发现报错了，系统提示内存溢出了 134217728 bytes 大概是134MB, 我们再查看一下PHP配置文件\n\n![](http://images.linyiyuan.top/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190907150407.png\n)\n\n果不其然，配置文件限制的内存最大值是128 我们执行该程序的内存使用明显超出限制，这时候我们只能修改此配置文件使其限制内存更大些，但是如果遇到超级大的数据量，或者让你去处理一个几个G的Excel文件时，你会发现修改这个配置文件并不能从根本解决问题，配置内存还需要考虑到服务器的内存使用情况等等，\n\n## 认识Yield\n这时候我们就可以使用 `Yield` 这个强大的神器，下面我们使用`Yield` 优化我们上面的代码\n\n```php\n$start_memory = memory_get_usage();\n\nfunction yield_range($start, $end) {\n\twhile( $start <= $end ){\n    $start++;\n    yield $start;\n  }\n}\n\n$numberArr = yield_range(1, 10000000);\nforeach($numberArr as $key) {\n  // echo $key;\n}\n$end_memory = memory_get_usage();\n\necho '运行该迭代数组所耗内存：'  . ($end_memory - $start_memory) . ' bytes';\n```\n\n运行一下，让你们感受下\n\n    运行该迭代数组所耗内存：320 bytes\n\n我擦，使用内存竟然连1kb都没有，那么，我们来分析一波儿这个神奇的yield_range函数。这个yield关键字到底返回的是什么？我们简单看一下：\n\n```php\nfunction yield_range( $start, $end ){\n while( $start <= $end ){\n $start++;\n yield $start;\n }\n}\n$rs = yield_range( 1, 100 );\n\nvar_dump( $rs );\n\n```\n\n\n     /*\n     object(Generator)#1 (0) {\n     }\n     */\n\n## Generator\n\n`Yield` 返回的是一个叫做Generator（中文名就是生成器）的object对象，该对象是由generators(生成器)返回，不能通过new实例化，而这个生成器是实现了Iterator接口，该接口提供了一下几个方法：\n\n1. abstract public [current](https://www.php.net/manual/zh/iterator.current.php) ( void ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed)\n2. abstract public [key](https://www.php.net/manual/zh/iterator.key.php) ( void ) : scalar\n3. abstract public [next](https://www.php.net/manual/zh/iterator.next.php) ( void ) : void\n4. abstract public [rewind](https://www.php.net/manual/zh/iterator.rewind.php) ( void ) : void\n5. abstract public [valid](https://www.php.net/manual/zh/iterator.valid.php) ( void ) : bool\n\n而Generator又包含一下几个方法：\n\n*   [Generator::current](https://www.php.net/manual/zh/generator.current.php) — 返回当前产生的值\n*   [Generator::key](https://www.php.net/manual/zh/generator.key.php) — 返回当前产生的键\n*   [Generator::next](https://www.php.net/manual/zh/generator.next.php) — 生成器继续执行\n*   [Generator::rewind](https://www.php.net/manual/zh/generator.rewind.php) — 重置迭代器\n*   [Generator::send](https://www.php.net/manual/zh/generator.send.php) — 向生成器中传入一个值\n*   [Generator::throw](https://www.php.net/manual/zh/generator.throw.php) — 向生成器中抛入一个异常\n*   [Generator::valid](https://www.php.net/manual/zh/generator.valid.php) — 检查迭代器是否被关闭\n*   [Generator::__wakeup](https://www.php.net/manual/zh/generator.wakeup.php) — 序列化回调\n\n\n所以，既然实现了Iterator接口（也正是因为如此，这个东西可以使用foreach进行迭代，明白了吧？），所以可以有如下代码：\n\n```php\n<?php\nfunction yield_range( $start, $end ){\n while( $start <= $end ){\n yield $start;\n $start++;\n }\n}\n$generator = yield_range( 1, 10 );\n\n// valid() current() next() 都是Iterator接口中的方法\n\nwhile( $generator->valid() ){\n echo $generator->current().PHP_EOL;\n $generator->next();\n}\n```\n\n\n    1 2 3 4 5 6 7 8 9 10\n\n  重点来了：这个yield_range函数似乎能够记住它上一次运行到哪儿了，上一次运行的结果是什么，然后紧接着在下一次运行的时候继续从上次终止的地方继续开始。这不是普通的PHP函数可以做得到的！\n\n我们知道，操作系统在调度进程的时候，会触发一个叫做“进程上下文切换”的概念。比如CPU从进程A调度给进程B了，那么当再次从进程B调度给进程A的时候，当初进程A运行到哪儿了、临时的数据结果是什么都是需要被还原的，不然，一切都要从头，那就要出大问题了。而，这个yield关键字，似乎在用户态（非系统内核级）就可以实现这个概念.\n\n接下来我们来认识一个Generator对象的一个方法 --send \n  \n```php\n<?php\nfunction yield_range( $start, $end ){\n   while( $start <= $end ){\n   $ret = yield $start;\n   $start++;\n   echo \"yield receive : \".$ret.PHP_EOL;\n   }\n}\n$generator = yield_range( 1, 10 );\n$generator->send( $generator->current() * 10 );\n```\n\n    //执行结果\n    yield receive : 10\n\nsend方法可以修改yield的返回值 , 我们继续修改代码\n\n```php\n<?php\nfunction yield_range( $start, $end ){\n  while( $start <= $end ){\n    $ret = yield $start;\n    $start++;\n    echo \"yield receive : \".$ret . PHP_EOL;\n  }\n}\n$generator = yield_range( 1, 10 );\nforeach( $generator as $item ){\n  $generator->send( $generator->current() * 10 );\n}\n```\n\n结果发现\n\n![](http://images.linyiyuan.top/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190907154456.png)\n\n这是PHP存在的一个Bug, 我们需要注意的是我们在foreach 去使用生成器的send方法，以下是bug的链接，有兴趣的可以去看下\n\n[https://bugs.php.net/bug.php?id=76104](https://bugs.php.net/bug.php?id=76104) [https://stackoverflow.com/questions/37817315/how-does-generatorsend-work](https://stackoverflow.com/questions/37817315/how-does-generatorsend-work)\n\n## 引用文章\n\n1. [PHP中的yield（上)](https://github.com/elarity/advanced-php/blob/master/17.%20PHP%E4%B8%AD%E7%9A%84yield%EF%BC%88%E4%B8%8A%EF%BC%89.md)\n2. [生成器类](https://www.php.net/manual/zh/class.generator.php)\n3. [Iterator（迭代器）接口](https://www.php.net/manual/zh/class.iterator.php)\n4. [PHP内置函数memory_get_usage()获取内存使用和getrusage()返回CUP使用情况](https://blog.csdn.net/h330531987/article/details/78993933)\n",[[1630380690280,["Administrator@YMS-20200313EGD",[[-1,115,"6"]],[116,116],[115,115]]],[1630380691161,["Administrator@YMS-20200313EGD",[[1,115,"7"]],[115,115],[116,116]]]],null,"Administrator@YMS-20200313EGD"]]}