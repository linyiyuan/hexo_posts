{"compress":true,"commitItems":[["8ef0002b-f2f7-4b0f-a0d7-8735d2d302bb",1630380684090,"---\nlayout: PHP设计模式——建造者模式\ntitle: PHP设计模式——建造者模式\ndate: 2019-08-15 14:42:45\ncategories: \"PHP\"\nabbrlink: 005a\ntags: \n- PHP\n- 设计模式\n---\n\n<img src=\"http://images.linyiyuan.top/3897939-3d84c8a531e21505.png\" style=\"width:900px;height:400px\" />\n\n> 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。\n\n<!--less-->\n\n## 前言\n 建造者模式也称生成器模式，核心思想是将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。\n\n\n![27194147](http://images.linyiyuan.top/2025309-b87a0396c5193070.png)\n\n\n建造者模式一般认为有四个角色：\n\n1. 产品角色，产品角色定义自身的组成属性\n\n2. 抽象建造者，抽象建造者定义了产品的创建过程以及如何返回一个产品\n\n3. 具体建造者，具体建造者实现了抽象建造者创建产品过程的方法，给产品的具体属性进行赋值定义\n\n4. 指挥者，指挥者负责与调用客户端交互，决定创建什么样的产品\n\n为什么使用：\n1. 对象的生产需要复杂的初始化，比如给一大堆类成员属性赋初值，设置一下其他的系统环境变量。使用建造者模式可以将这些初始化工作封装起来。\n2. 对象的生成时可根据初始化的顺序或数据不同，而生成不同角色。\n3. 例如：汽车，他的发动机引擎有好多品牌，轮胎也有各种材质，内饰更是千奇百怪；鸟，他的头、翅膀以及脚有各种颜色和形状，在创建这种复杂对象的时候，我们建议使用建造者模式。\n\n## 应用\n\n在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物\n\n## 实例\n以下将用一个大家比较熟悉的游戏《英雄联盟》 作为一个简单的例子，现在我们想创建一个角色，我们通过使用建造者模式去设计如果创建不同的属性的角色\n\n```php\n/**\n * Class Role\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义一个角色类\n */\nclass Role\n{\n    /**\n     * 姓名\n     * @var string\n     */\n    public $name;\n\n    /**\n     * 攻击力\n     * @var integer\n     */\n    public $power;\n\n    /**\n     * 攻速\n     * @var float\n     */\n    public $attack_speed;\n\n    /**\n     * 暴击\n     * @var integer\n     */\n    public $crit;\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @description 显示信息\n     */\n    public function display()\n    {\n        echo '姓名：' . $this->name . '<br>';\n        echo '攻击力：' . $this->power . '<br>';\n        echo '攻击速度：' . $this->attack_speed . '<br>';\n        echo '暴击几率：' . $this->crit . '<br>';\n    }\n}\n\n/**\n * Class RoleBuilder\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义一个射手抽象类\n */\nabstract class RoleBuilder\n{\n    public $_role;\n\n    /**\n     * ShooterBuilder constructor.\n     * 初始化一个射手\n     */\n    public function __construct()\n    {\n        $this->_role = new Role();\n    }\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置名字\n     */\n    abstract public function setName();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置力量值\n     */\n    abstract public function setPower();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置攻击速度\n     */\n    abstract public function setAttackSpeed();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置暴击几率\n     */\n    abstract public function setCrit();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 建立角色\n     */\n    abstract public function builder();\n\n}\n\n\n/**\n * Class Ez\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义个伊泽瑞尔射手\n */\nclass Ez extends RoleBuilder\n{\n    public function setName()\n    {\n        // TODO: Implement setName() method.\n        $this->_role->name = '伊泽瑞尔';\n    }\n\n    public function setPower()\n    {\n        // TODO: Implement setPower() method.\n        $this->_role->power = 100;\n    }\n\n    public function setAttackSpeed()\n    {\n        // TODO: Implement setAttackSpeed() method.\n        $this->_role->attack_speed = 0.75;\n    }\n\n    public function setCrit()\n    {\n        // TODO: Implement setCrit() method.\n        $this->_role->crit = 0;\n    }\n\n    public function builder()\n    {\n        // TODO: Implement builder() method.\n        return $this->_role;\n    }\n}\n\n/**\n * Class AoBaMa\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义一个奥巴马的角色\n */\nclass AoBaMa extends RoleBuilder\n{\n    public function setName()\n    {\n        // TODO: Implement setName() method.\n        $this->_role->name = '奥巴马';\n    }\n\n    public function setPower()\n    {\n        // TODO: Implement setPower() method.\n        $this->_role->power = 200;\n    }\n\n    public function setAttackSpeed()\n    {\n        // TODO: Implement setAttackSpeed() method.\n        $this->_role->attack_speed = 2.50;\n    }\n\n    public function setCrit()\n    {\n        // TODO: Implement setCrit() method.\n        $this->_role->crit = 100;\n    }\n\n    public function builder()\n    {\n        // TODO: Implement builder() method.\n        return $this->_role;\n    }\n}\n\nclass RoleDirector\n{\n    private $_role;\n    public function __construct(RoleBuilder $role)\n    {\n        $this->_role = $role;\n    }\n\n    public function build()\n    {\n        $this->_role->setName();\n        $this->_role->setPower();\n        $this->_role->setAttackSpeed();\n        $this->_role->setCrit();\n\n        return $this->_role->builder();\n    }\n}\n\n\n$anBaMaRole = new RoleDirector(new AoBaMa());\n$anBaMaRole = $anBaMaRole->build();\n$anBaMaRole->display();\n\n//var_dump($anBaMaRole);\necho '<br>';\n\n$ezRole = new RoleDirector(new Ez());\n$ezRole = $ezRole->build();\n$ezRole->display();\n\n//var_dump($ezRole);\n\n```\n\n## 总结\n使用建造者模式时，我们把创建一个role实例的过程分为了两步.\n\n一步是先交给对应角色的建造者，如Ez建造者。这样的好处就把角色的属性设置封装了起来，我们不用在new一个Role时，因为要得到一个Ez角色的实例，而在外面写了一堆$ez->power=70。\n\n另一步是交给了一个建造指挥者，调了一个built方法，通过先设置power，再设置Crit的顺序，初始化这个角色。当然在这个例子中，初始化的顺序，是无所谓的。但是如果对于一个建造汉堡，或是地图，初始化的顺序不同，可能就会得到不同的结果。\n\n也许，你会说，我直接设置也很方便呀。是的，对于某些情况是这样的。但是如果你考虑，我现在想增加一个寒冰角色呢？如果我现在想让建造有初始化有三种不同的顺序呢？\n\n如果你使用了建造者模式，这两个问题就简单了，增加一个寒冰角色，那就增加一个寒冰建造者类。初始化三种不同的顺序，那么就在指挥建造者中增加两种建造方法。\n",[[1630380683304,["Administrator@YMS-20200313EGD",[[-1,105,"5"]],[106,106],[105,105]]],[1630380683835,["Administrator@YMS-20200313EGD",[[1,105,"6"]],[105,105],[106,106]]]],null,"Administrator@YMS-20200313EGD"],["e8e98aa5-1680-4f08-aa32-fdf77fdcf98b",1630381409682,"---\nlayout: PHP设计模式——建造者模式\ntitle: PHP设计模式——建造者模式\ndate: 2019-08-15 14:42:45\ncategories: \"PHP\"\nabbrlink: 006a\ntags: \n- PHP\n- 设计模式\n---\n\n<img src=\"http://images.linyiyuan.top/3897939-3d84c8a531e21505.png\" style=\"width:900px;height:400px\" />\n\n> 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。\n\n<!--less-->\n\n## 前言\n 建造者模式也称生成器模式，核心思想是将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。\n\n\n![27194147](http://images.linyiyuan.top/2025309-b87a0396c5193070.png)\n\n\n建造者模式一般认为有四个角色：\n\n1. 产品角色，产品角色定义自身的组成属性\n\n2. 抽象建造者，抽象建造者定义了产品的创建过程以及如何返回一个产品\n\n3. 具体建造者，具体建造者实现了抽象建造者创建产品过程的方法，给产品的具体属性进行赋值定义\n\n4. 指挥者，指挥者负责与调用客户端交互，决定创建什么样的产品\n\n为什么使用：\n1. 对象的生产需要复杂的初始化，比如给一大堆类成员属性赋初值，设置一下其他的系统环境变量。使用建造者模式可以将这些初始化工作封装起来。\n2. 对象的生成时可根据初始化的顺序或数据不同，而生成不同角色。\n3. 例如：汽车，他的发动机引擎有好多品牌，轮胎也有各种材质，内饰更是千奇百怪；鸟，他的头、翅膀以及脚有各种颜色和形状，在创建这种复杂对象的时候，我们建议使用建造者模式。\n\n## 应用\n\n在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物\n\n## 实例\n以下将用一个大家比较熟悉的游戏《英雄联盟》 作为一个简单的例子，现在我们想创建一个角色，我们通过使用建造者模式去设计如果创建不同的属性的角色\n\n```php\n/**\n * Class Role\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义一个角色类\n */\nclass Role\n{\n    /**\n     * 姓名\n     * @var string\n     */\n    public $name;\n\n    /**\n     * 攻击力\n     * @var integer\n     */\n    public $power;\n\n    /**\n     * 攻速\n     * @var float\n     */\n    public $attack_speed;\n\n    /**\n     * 暴击\n     * @var integer\n     */\n    public $crit;\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @description 显示信息\n     */\n    public function display()\n    {\n        echo '姓名：' . $this->name . '<br>';\n        echo '攻击力：' . $this->power . '<br>';\n        echo '攻击速度：' . $this->attack_speed . '<br>';\n        echo '暴击几率：' . $this->crit . '<br>';\n    }\n}\n\n/**\n * Class RoleBuilder\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义一个射手抽象类\n */\nabstract class RoleBuilder\n{\n    public $_role;\n\n    /**\n     * ShooterBuilder constructor.\n     * 初始化一个射手\n     */\n    public function __construct()\n    {\n        $this->_role = new Role();\n    }\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置名字\n     */\n    abstract public function setName();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置力量值\n     */\n    abstract public function setPower();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置攻击速度\n     */\n    abstract public function setAttackSpeed();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 设置暴击几率\n     */\n    abstract public function setCrit();\n\n    /**\n     * @Author YiYuan-LIn\n     * @Date: 2019/8/15\n     * @enumeration:\n     * @return mixed\n     * @description 建立角色\n     */\n    abstract public function builder();\n\n}\n\n\n/**\n * Class Ez\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义个伊泽瑞尔射手\n */\nclass Ez extends RoleBuilder\n{\n    public function setName()\n    {\n        // TODO: Implement setName() method.\n        $this->_role->name = '伊泽瑞尔';\n    }\n\n    public function setPower()\n    {\n        // TODO: Implement setPower() method.\n        $this->_role->power = 100;\n    }\n\n    public function setAttackSpeed()\n    {\n        // TODO: Implement setAttackSpeed() method.\n        $this->_role->attack_speed = 0.75;\n    }\n\n    public function setCrit()\n    {\n        // TODO: Implement setCrit() method.\n        $this->_role->crit = 0;\n    }\n\n    public function builder()\n    {\n        // TODO: Implement builder() method.\n        return $this->_role;\n    }\n}\n\n/**\n * Class AoBaMa\n * @Author YiYuan-LIn\n * @Date: 2019/8/15\n * 定义一个奥巴马的角色\n */\nclass AoBaMa extends RoleBuilder\n{\n    public function setName()\n    {\n        // TODO: Implement setName() method.\n        $this->_role->name = '奥巴马';\n    }\n\n    public function setPower()\n    {\n        // TODO: Implement setPower() method.\n        $this->_role->power = 200;\n    }\n\n    public function setAttackSpeed()\n    {\n        // TODO: Implement setAttackSpeed() method.\n        $this->_role->attack_speed = 2.50;\n    }\n\n    public function setCrit()\n    {\n        // TODO: Implement setCrit() method.\n        $this->_role->crit = 100;\n    }\n\n    public function builder()\n    {\n        // TODO: Implement builder() method.\n        return $this->_role;\n    }\n}\n\nclass RoleDirector\n{\n    private $_role;\n    public function __construct(RoleBuilder $role)\n    {\n        $this->_role = $role;\n    }\n\n    public function build()\n    {\n        $this->_role->setName();\n        $this->_role->setPower();\n        $this->_role->setAttackSpeed();\n        $this->_role->setCrit();\n\n        return $this->_role->builder();\n    }\n}\n\n\n$anBaMaRole = new RoleDirector(new AoBaMa());\n$anBaMaRole = $anBaMaRole->build();\n$anBaMaRole->display();\n\n//var_dump($anBaMaRole);\necho '<br>';\n\n$ezRole = new RoleDirector(new Ez());\n$ezRole = $ezRole->build();\n$ezRole->display();\n\n//var_dump($ezRole);\n\n```\n\n## 总结\n使用建造者模式时，我们把创建一个role实例的过程分为了两步.\n\n一步是先交给对应角色的建造者，如Ez建造者。这样的好处就把角色的属性设置封装了起来，我们不用在new一个Role时，因为要得到一个Ez角色的实例，而在外面写了一堆$ez->power=70。\n\n另一步是交给了一个建造指挥者，调了一个built方法，通过先设置power，再设置Crit的顺序，初始化这个角色。当然在这个例子中，初始化的顺序，是无所谓的。但是如果对于一个建造汉堡，或是地图，初始化的顺序不同，可能就会得到不同的结果。\n\n也许，你会说，我直接设置也很方便呀。是的，对于某些情况是这样的。但是如果你考虑，我现在想增加一个寒冰角色呢？如果我现在想让建造有初始化有三种不同的顺序呢？\n\n如果你使用了建造者模式，这两个问题就简单了，增加一个寒冰角色，那就增加一个寒冰建造者类。初始化三种不同的顺序，那么就在指挥建造者中增加两种建造方法。\n",[[1630381399025,["Administrator@YMS-20200313EGD",[[-1,240,"建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。"]],[240,300],[240,240]]],[1630381401824,["Administrator@YMS-20200313EGD",[[-1,241,"\n"]],[240,240],[240,240]]],[1630381402152,["Administrator@YMS-20200313EGD",[[-1,240,"\n"]],[240,240],[240,240]]],[1630381402873,["Administrator@YMS-20200313EGD",[[1,240,"\n"]],[240,240],[240,240]]],[1630381404456,["Administrator@YMS-20200313EGD",[[-1,238,"> "]],[240,240],[238,238]]],[1630381408312,["Administrator@YMS-20200313EGD",[[1,238,"> "]],[238,238],[240,240]]],[1630381408812,["Administrator@YMS-20200313EGD",[[1,241,"\n"]],[240,240],[240,240]]],[1630381408860,["Administrator@YMS-20200313EGD",[[1,240,"建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。"]],[240,240],[240,300]]]],null,"Administrator@YMS-20200313EGD"]]}